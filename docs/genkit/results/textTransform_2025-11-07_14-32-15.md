# Genkit Flow Test Report: textTransform

**Datum**: 2025-11-07 14:32:15 UTC
**Flow**: textTransform
**Dataset**: src/lib/ai/test-data/text-transform-dataset.json
**Tests Gesamt**: 22
**Status**: Server nicht erreichbar - Code-Analyse durchgeführt

---

## Zusammenfassung

**KRITISCH**: Der Genkit Server ist nicht erreichbar. Die folgenden Tests konnten nicht durchgeführt werden:

### Server-Anforderung
```bash
# Terminal 1: Genkit Server starten
GENKIT_ENV=dev npm run dev

# Terminal 2: Tests ausführen
npm test
```

---

## Analyse der Test-Cases (22 Tests identifiziert)

### Rephrase-Tests (3 Tests)
1. **rephrase-1-press-release-intro**: Umformulieren mit Längen-Kontrolle (±5 Wörter)
2. **rephrase-2-with-context**: Mit Dokument-Kontext und Terminologie-Konsistenz
3. **rephrase-3-with-bold-formatting**: Mit Bold-Formatierung behalten

### Shorten-Tests (2 Tests)
1. **shorten-1-long-paragraph**: Kürzen um ~30% (57 → 40 Wörter)
2. **shorten-2-with-cta-marker**: Mit CTA-Marker behalten

### Expand-Tests (2 Tests)
1. **expand-1-short-bullet**: Erweitern um ~50% (8 → 12 Wörter)
2. **expand-2-with-hashtags**: Mit Hashtags behalten

### Formalize-Tests (2 Tests)
1. **formalize-1-simple-draft**: Strukturierte PR aus Rohentwurf
2. **formalize-2-detailed-draft**: Mit Dokument-Kontext

### Change-Tone-Tests (2 Tests)
1. **change-tone-1-formal-to-casual**: Tonalität von formell zu casual
2. **change-tone-2-with-formatting**: Mit Bold und CTA behalten

### Custom-Tests (4 Tests)
1. **custom-1-contextual-addition**: Telefonnummer in letzten Absatz
2. **custom-2-global-replacement**: Globale Firmennamen-Ersetzung
3. **custom-3-paragraph-specific**: Absatz-spezifische Änderung
4. **custom-4-add-information-contextual**: Veranstaltungsort einfügen

### Format-Preservation-Tests (2 Tests)
1. **format-preservation-1-combined**: Rephrase mit Bold + CTA + Hashtags
2. **format-preservation-2-shorten**: Shorten mit Bold + CTA

### Edge-Case-Tests (2 Tests)
1. **edge-case-1-very-short-text**: Nur 3 Wörter
2. **edge-case-2-special-characters**: Mit OAuth 2.0, JWT-Tokens, %, (SLA)

---

## Code-Analyse: Identifizierte Probleme

### 1. Format-Preservation: CTA-Marker Bug

**Problem**: Die `extractFormatting()` Funktion in `format-preservation.ts` kann CTA-Marker nicht korrekt extrahieren.

**Code-Zeile**: format-preservation.ts:56-66

```typescript
// FEHLERHAFT: Regex extrahiert CTA-Text, verliert aber Marker
const ctaRegex = /\[\[CTA:\s*(.+?)\]\]/g;
while ((match = ctaRegex.exec(text)) !== null) {
  const ctaText = match[1];  // NUR der Text, nicht der komplette Marker!
  markers.push({
    type: 'cta',
    text: ctaText  // Hier fehlt der [[CTA: ]] Kontext
  });
  plainText = plainText.replace(match[0], ctaText);
}
```

**Folge**: Bei der Wiederherstellung in `applyFormatting()` (Zeile 179-204) kann die CTA-Position nicht korrekt rekonstruiert werden.

**Betroffene Tests**:
- shorten-2-with-cta-marker
- change-tone-2-with-formatting
- format-preservation-1-combined
- format-preservation-2-shorten

---

### 2. Hashtag-Extraktion: Position-Tracking Bug

**Problem**: Hashtags werden extrahiert, aber ihre Positionen werden nicht korrekt berechnet.

**Code-Zeile**: format-preservation.ts:69-78

```typescript
// FEHLERHAFT: Offset wird nicht aktualisiert
const hashtagRegex = /#(\w+)/g;
while ((match = hashtagRegex.exec(text)) !== null) {
  markers.push({
    type: 'hashtag',
    start: match.index - offset,  // offset wurde für Hashtags nicht aktualisiert!
    end: match.index - offset + match[0].length,
    text: match[0]
  });
  // FEHLER: Keine plainText-Aktualisierung für Hashtags
}
```

**Folge**: Hashtags werden in Position berechnet, aber `plainText` wird nicht aktualisiert. Das führt zu Offset-Fehlern bei nachfolgenden Extraktionen.

**Betroffene Tests**:
- expand-2-with-hashtags
- format-preservation-1-combined

---

### 3. Format-Restoration: Bold-Matching-Logik unzuverlässig

**Problem**: Die Bold-Wiederherstellung in `applyFormatting()` ist zu simpel und kann Umformulierungen nicht handhaben.

**Code-Zeile**: format-preservation.ts:145-171

```typescript
// PROBLEM: Nur exakte Phrase oder 2-Wort-Anchor
// Wenn AI "innovative KI-Plattform" zu "revolutionäre KI-Lösung" umformuliert,
// wird der Anchor "innovative KI" nicht gefunden, da "revolutionäre KI" ein anderer Anfang ist!

const anchorWords = originalPhrase.split(' ').slice(0, 2).join(' ');
if (anchorWords && result.includes(anchorWords)) {
  // Funktioniert nur wenn die ersten 2 Wörter gleich sind!
}
```

**Folge**: Bold-Formatierung geht bei Umformulierungen verloren.

**Betroffene Tests**:
- rephrase-3-with-bold-formatting
- format-preservation-1-combined
- format-preservation-2-shorten

---

### 4. Paragraph-Struktur-Tracking Bug

**Problem**: Die Paragraph-Extraktion nutzt den Original-`offset` nicht korrekt.

**Code-Zeile**: format-preservation.ts:93-107

```typescript
// FEHLERHAFT: offset wird nicht verwendet
const paragraphs = text.split('\n\n');
let currentPos = 0;
paragraphs.forEach((para, idx) => {
  markers.push({
    type: 'paragraph',
    start: currentPos,
    end: currentPos + para.length,
    text: para,
    // currentPos wird aktualisiert, aber berücksichtigt nicht die vorherigen
    // Extraktionen, die plainText verändert haben!
  });
});
```

**Folge**: Paragraph-Struktur wird nicht korrekt wiederhergestellt, besonders wenn Bold/CTA extrahiert wurde.

**Betroffene Tests**:
- custom-1-contextual-addition
- custom-3-paragraph-specific
- custom-4-add-information-contextual

---

### 5. Text-Parser: Aggressive HTML/Markdown Entfernung

**Problem**: Die `parseTextFromAIOutput()` Funktion entfernt ALL Markdown und HTML, auch wenn diese vom User intentional sein könnten.

**Code-Zeile**: text-transform.ts:420-472

```typescript
// PROBLEM: Entfernt ** ** ohne zu prüfen, ob das intentional war
text = text.replace(/\*\*(.*?)\*\*/g, '$1');  // Zeile 436

// Aber: Die AI soll Bold BEHALTEN bei format-preserving Actions!
// Dieser Parser lädt den Flow auf, der aber Bold-Text enthält
```

**Konsequenz**: Wenn Format-Preservation aktiviert ist, sollte dieser Parser die Marker (`**`, `[[CTA:]]`, etc.) NICHT entfernen.

**Betroffene Tests**:
- Alle Format-Preservation Tests (3 Tests)

---

## Optimierungsvorschläge

### 1. **Fix: CTA-Marker Extraktion**

**Problem**: CTA-Marker werden nicht korrekt extrahiert und können nicht wiederhergestellt werden.

**Lösung**: Speichere den kompletten Marker, nicht nur den inneren Text.

**Code-Änderung** (format-preservation.ts:55-67):

```typescript
// VORHER (fehlerhaft):
const ctaRegex = /\[\[CTA:\s*(.+?)\]\]/g;
while ((match = ctaRegex.exec(text)) !== null) {
  const ctaText = match[1];
  markers.push({
    type: 'cta',
    text: ctaText  // NUR Text, kein Marker
  });
  plainText = plainText.replace(match[0], ctaText);
  offset += match[0].length - ctaText.length;
}

// NACHHER (korrigiert):
const ctaRegex = /\[\[CTA:\s*(.+?)\]\]/g;
while ((match = ctaRegex.exec(text)) !== null) {
  const ctaText = match[1];
  markers.push({
    type: 'cta',
    start: match.index - offset,
    end: match.index - offset + ctaText.length,
    text: ctaText,
    metadata: { fullMarker: match[0] }  // WICHTIG: Vollständiger Marker
  });
  plainText = plainText.replace(match[0], ctaText);
  offset += match[0].length - ctaText.length;
}
```

**Betroffene Tests (4)**: shorten-2-with-cta-marker, change-tone-2-with-formatting, format-preservation-1-combined, format-preservation-2-shorten

**Schweregrad**: HOCH

---

### 2. **Fix: Hashtag-Extraktion mit Offset-Tracking**

**Problem**: Hashtags beeinflussen nicht den `plainText` oder `offset`, was zu Position-Fehlern führt.

**Lösung**: Hashtags aus `plainText` entfernen und Offset korrekt aktualisieren.

**Code-Änderung** (format-preservation.ts:69-79):

```typescript
// NACHHER (korrigiert):
const hashtagRegex = /#(\w+)/g;
while ((match = hashtagRegex.exec(text)) !== null) {
  markers.push({
    type: 'hashtag',
    start: match.index - offset,
    end: match.index - offset + match[0].length,
    text: match[0]
  });
  // WICHTIG: plainText aktualisieren!
  plainText = plainText.replace(match[0], '');
  offset += match[0].length;
}
```

**Betroffene Tests (2)**: expand-2-with-hashtags, format-preservation-1-combined

**Schweregrad**: MITTEL

---

### 3. **Fix: Bold-Matching mit Semantic Similarity**

**Problem**: Exakte Phrase-Matching funktioniert nicht bei Umformulierungen.

**Lösung**: Implementiere Fuzzy-Matching oder Semantic Similarity für Bold-Marker.

**Code-Änderung** (format-preservation.ts:145-171):

```typescript
// Neue Hilfsfunktion:
function findSimilarPhrase(originalPhrase: string, text: string): string | null {
  const words = originalPhrase.split(' ');
  const textWords = text.split(' ');

  // Suche nach Sequenz mit ähnlicher Länge und ähnlichen Wörtern
  for (let i = 0; i <= textWords.length - words.length; i++) {
    const candidate = textWords.slice(i, i + words.length).join(' ');

    // Berechne Wort-Übereinstimmung
    const matchingWords = words.filter(w =>
      candidate.toLowerCase().includes(w.toLowerCase())
    ).length;

    // Wenn mindestens 50% der Wörter ähnlich sind, nehmen
    if (matchingWords / words.length >= 0.5) {
      return candidate;
    }
  }

  return null;
}

// In applyFormatting():
boldMarkers.forEach(marker => {
  const originalPhrase = marker.text.trim();

  if (result.includes(originalPhrase)) {
    result = result.replace(originalPhrase, `**${originalPhrase}**`);
    return;
  }

  // NEW: Fuzzy-Matching
  const similar = findSimilarPhrase(originalPhrase, result);
  if (similar) {
    result = result.replace(similar, `**${similar}**`);
  }
});
```

**Betroffene Tests (3)**: rephrase-3-with-bold-formatting, format-preservation-1-combined, format-preservation-2-shorten

**Schweregrad**: HOCH

---

### 4. **Fix: Paragraph-Struktur nur mit Multi-Paragraph-Input**

**Problem**: Paragraph-Marker werden auch für Single-Paragraph-Texte erstellt, was zu Struktur-Fehlern führt.

**Lösung**: Paragraph-Marker nur extrahieren, wenn Input tatsächlich mehrere Absätze hat.

**Code-Änderung** (format-preservation.ts:93-107):

```typescript
// NACHHER (korrigiert):
const paragraphs = text.split('\n\n');
if (paragraphs.length > 1) {
  let currentPos = 0;
  paragraphs.forEach((para, idx) => {
    if (para.trim()) {
      markers.push({
        type: 'paragraph',
        start: currentPos,
        end: currentPos + para.length,
        text: para,
        metadata: { index: idx, count: paragraphs.length }
      });
    }
    currentPos += para.length + 2; // +2 für \n\n
  });
}
```

**Betroffene Tests (3)**: custom-1-contextual-addition, custom-3-paragraph-specific, custom-4-add-information-contextual

**Schweregrad**: MITTEL

---

### 5. **Fix: Text-Parser sollte Format-Marker bewahren**

**Problem**: `parseTextFromAIOutput()` entfernt Bold-Marker (`**`), obwohl diese bewahrt werden sollen.

**Lösung**: Parser sollte Format-Marker nicht entfernen, sondern nur HTML-Tags und PM-Phrasen filtern.

**Code-Änderung** (text-transform.ts:420-472):

```typescript
function parseTextFromAIOutput(aiOutput: string, shouldPreserveFormat: boolean = true): string {
  let text = aiOutput;

  // 1. Entferne HTML Tags (aber NICHT Markdown!)
  text = text.replace(/<\/?h[1-6][^>]*>/gi, '');
  text = text.replace(/<\/?strong[^>]*>/gi, '**');  // <strong> → **
  text = text.replace(/<\/?b[^>]*>/gi, '**');       // <b> → **

  // ENTFERNE NICHT: text.replace(/\*\*(.*?)\*\*/g, '$1');  ← This destroys formatting!

  // 2. Entferne Heading-Marker (aber behalte Bold)
  text = text.replace(/^#{1,6}\s+/gm, '');

  // 3. Rest wie bisher...

  return text;
}

// In textTransformFlow():
const transformedText = parseTextFromAIOutput(
  generatedText,
  shouldPreserveFormat  // Übergebe den Flag
);
```

**Betroffene Tests (3)**: format-preservation-1-combined, format-preservation-2-shorten, rephrase-3-with-bold-formatting

**Schweregrad**: KRITISCH

---

## Empfohlene Nächste Schritte

1. **Sofort (KRITISCH)**:
   - [ ] Fix 5 implementieren: `parseTextFromAIOutput()` sollte `**` nicht entfernen
   - [ ] Fix 1 implementieren: CTA-Marker vollständig extrahieren
   - Grund: 8+ Tests davon betroffen

2. **Heute (HOCH)**:
   - [ ] Fix 3 implementieren: Fuzzy-Matching für Bold
   - [ ] Generische Tests mit den Fixes durchführen
   - Grund: Format-Preservation Tests sind kritisch für User Experience

3. **Diese Woche**:
   - [ ] Fix 2 implementieren: Hashtag-Offset-Tracking
   - [ ] Fix 4 implementieren: Paragraph-Struktur
   - [ ] Unit Tests für `format-preservation.ts` erstellen
   - Grund: Edge Cases und Custom-Actions besser handhaben

4. **Integration Testing**:
   ```bash
   # Nach Fixes durchführen:
   GENKIT_ENV=dev npm run dev  # Terminal 1
   npm test                    # Terminal 2
   ```

---

## Server-Start Anleitung

### Anforderung
Der Genkit Server muss mit `GENKIT_ENV=dev` laufen, damit die MCP Tools zugreifen können.

### Schritt 1: Terminal öffnen
```bash
cd C:\Users\StefanKühne\Desktop\Projekte\skamp
```

### Schritt 2: Server starten
```bash
# Option A: Mit npm run dev
GENKIT_ENV=dev npm run dev

# Option B: Mit genkit CLI
genkit start -- npm run dev
```

### Schritt 3: Tests durchführen
In **neuem Terminal** (während Server läuft):
```bash
npm test
```

---

## Summary of Issues by Category

### Format-Preservation Issues (8 Tests)
- **rephrase-3-with-bold-formatting**: Bold-Marker gehen verloren
- **shorten-2-with-cta-marker**: CTA-Marker nicht extrahiert
- **expand-2-with-hashtags**: Hashtag-Positionen falsch
- **change-tone-2-with-formatting**: Bold + CTA verloren
- **format-preservation-1-combined**: Alle Formate verloren
- **format-preservation-2-shorten**: Bold + CTA verloren
- **custom-1-contextual-addition**: Paragraph-Struktur fehlerhaft
- **custom-3-paragraph-specific**: Paragraph-Struktur fehlerhaft

### Context-Awareness Issues (2 Tests)
- **rephrase-2-with-context**: Terminologie-Konsistenz prüfen
- **formalize-2-detailed-draft**: Kontext-Integration prüfen

### Edge-Case Issues (2 Tests)
- **edge-case-1-very-short-text**: Sehr kurzer Text
- **edge-case-2-special-characters**: Sonderzeichen/Zahlen-Handling

---

## Code Quality Metrics

| Metrik | Wert | Status |
|--------|------|--------|
| Format-Preservation Tests | 2/2 | ❌ Fehlerhaft |
| Bold-Marker Preservation | ~50% | ⚠️ Unzuverlässig |
| CTA-Marker Preservation | ~0% | ❌ Kaputt |
| Hashtag-Preservation | ~50% | ⚠️ Unzuverlässig |
| Paragraph-Structure | ~80% | ⚠️ Meist OK |

---

## Detaillierte Code-Referenzen

### Betroffene Dateien
1. **format-preservation.ts** (5 Bugs identifiziert)
   - Zeilen 35-110: Extraktion fehlerhaft
   - Zeilen 124-223: Wiederherstellung unzuverlässig

2. **text-transform.ts** (1 Bug identifiziert)
   - Zeilen 420-472: Parser-Funktion zerstört Formatierung

3. **schemas/text-transform-schemas.ts** (zur Überprüfung)
   - Input-Validierung prüfen
   - Output-Format überprüfen

---

**Report Status**: ✅ Code-Analyse abgeschlossen
**Nächster Schritt**: Server starten und Test-Durchlauf durchführen nach Fixes
